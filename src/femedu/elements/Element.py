import numpy as np
import os
import sys
from .DrawElement import *
from ..recorder.Recorder import Recorder


class Element(DrawElement):
    """
    abstract class: representing a single generic element
    """

    def __init__(self, nodes, material):
        """

        :param nodes:
        :param material:
        """
        super(Element, self).__init__()
        
        self.nodes    = nodes
        self.transforms = [ None for nd in self.nodes ]
        self.material = material
        self.dof_idx  = {}

        self._requestDofs( tuple() )

        self.force    = 0.0
        self.Loads    = [ [] for i in range(len(nodes)) ]
        self.Forces   = []
        self.Kt       = []

        self.setRecorder(None)

        self.setLoadFactor(1.0)


    def __str__(self):
        s = "{}: nodes ( ".format(self.__class__.__name__)
        for node in self.nodes:
            s += "{} ".format(node.getID())
        s += ")"
        s += "\n    material: {}".format(self.material.__class__.__name__)
        return s

    def __repr__(self):
        fmt = "{}(" + len(self.nodes)*"{}, " + "{})"
        return fmt.format(self.__class__.__name__,
                                *[ node.getID() for node in self.nodes ],
                                repr(self.material))

    def resetLoads(self):
        """
        default implementation for resetting element loads.
        """
        pass

    def setSurfaceLoad(self, face, w):
        """
        .. warning::

            This method needs to be implemented by every element that shall accept a surface load.

        :param face: face ID for the laoded face
        :param w: magnitude of distributed load per area. Tension on a surface is positive.
        """
        raise NotImplementedError(msg)

    def addTransformation(self, T, local_nodes=[]):
        """
        Attach a transformation to any node of the element.

        If no **local_nodes** list is given or an empty list is handed to the function,
        the transformation, **T**, will be applied to all nodes in the element.

        A non-empty **local_nodes** list will apply the transformation to those local nodes listed in that list.
        Local nodes start at 0 and go to N-1, where N is the number of elements in this element.

        A transformation can be removed from a node by assigning :code:`T=None` as the transformation.
        """
        if local_nodes:
            for local_id in local_nodes:
                if local_id >= 0 and local_id < len(self.transforms):
                    self.transforms[local_id] = T
        else:
            self.transforms = [ T for nd in self.nodes ]

    def getForce(self):
        """
        Request the internal force vector (stress driven force only; **no applied element loads**)

        :return:
        """
        self.updateState()
        return self.Forces

    def getLoad(self, apply_load_factor=False):
        """
        Requesting nodal forces generated by element loads, like

        * line loads on beams of frames
        * surface loads on plates or solids
        * body forces on solids.

        :param apply_load_factor: shall the global load factor be applied by the element.

        :return:  element load vector
        """
        self.updateState()
        if self.Loads:
            return self.Loads
        else:
            return [ None for k in self.nodes ]

    def getInternalForce(self, variable=''):
        msg = "{}(Element): getInternalForce() method has not been implemented".format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def getStress(self):
        self.updateState()
        return None

    def getStiffness(self):
        """

        :return:
        """
        self.updateState()
        return self.Kt

    def updateState(self):
        """

        """
        msg = "{}(Element): updateState() method has not been implemented".format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def _requestDofs(self, dof_requests):
        """
        Helper function (internal use) to inform **all** nodes of this element about the needed/used
        degrees of freedom.

        **Remark**: if nodes of different type are to be used by the element, **DO NOT** use this method but
        implement your own overloaded initialization within the constructor of your element.

        :param dof_requests: list of dofs for a typical node in this element
        """
        for node in self.nodes:
            dof_idx = node.request(dof_requests, self)
            self.dof_idx[node] = dof_idx

    def getDofs(self):
        """
        returns the dof-codes for this element in a list
        """
        return self.dof_list

    def setLoadFactor(self, lam):
        """
        Set the target load factor to **lam**

        .. warning::

            This method should not be called by the user.
            **USE** :code:`System.setLoadFactor(lam)` instead!

        The entered load pattern is considered a reference load,
        to be multiplied by a scalar load factor, :math:`\lambda`.

        If no load factor is set explicitly, a factor of 1.0 is assumed, i.e., the
        entire entered load is applied in full.
        """
        self.loadfactor = lam

    def setRecorder(self, recorder):
        if isinstance(recorder, Recorder):
            self.recorder = recorder
        else:
            self.recorder = None

    def recordThisStep(self, load_level):
        """
        record current state of the system
        """
        if self.recorder and self.recorder.isActive():
            data = {'lam':self.load_level}
            self.recorder.addData(data)


if __name__ == "__main__":

    sys.path.insert(0, os.path.abspath(".."))

    from ..domain import Node
    from ..materials import Material

    # testing the Element class
    nd0 = Node(0.0, 0.0)
    nd0.index = 0
    nd1 = Node(3.0, 2.0)
    nd1.index = 1
    params = {'E':100, 'A':1.5, 'fy':1.0e20}
    mat = Material(params)
    elem = Element([nd0, nd1], mat)

    print(nd0)
    print(nd1)

    print("force =", elem.getAxialForce())
    print("nodal forces: ", *elem.getForce())
    print("element stiffness: ", elem.getStiffness())

    # change the nodal displacements
    nd0.setDisp(.1, .05)
    nd1.setDisp(.05, .2)

    print(nd0)
    print(nd1)

    print("force =", elem.getAxialForce())
    print("nodal forces: ", *elem.getForce())
    print("element stiffness: ", elem.getStiffness())


